name: Sync Mod Versions

on:
  schedule:
    # Run every 6 hours
    - cron: '0 */6 * * *'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run (no commits)'
        required: false
        default: 'false'
  push:
    paths:
      - 'mods.json'

permissions:
  contents: write

jobs:
  sync-versions:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests

      - name: Sync mod versions
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DRY_RUN: ${{ github.event.inputs.dry_run || 'false' }}
        run: |
          python << 'EOF'
          import json
          import os
          import re
          import sys
          from pathlib import Path
          from typing import Dict, List, Optional, Tuple
          import requests

          VERSION_CANDIDATE_RE = re.compile(
              r"(?<!\d)v?(?P<major>\d+)(?:[._](?P<minor>\d+))(?:[._](?P<patch>\d+))?",
              re.IGNORECASE,
          )


          def get_github_token() -> str:
              """Get GitHub token from environment."""
              token = os.environ.get('GITHUB_TOKEN', '')
              if not token:
                  print("âš ï¸  No GitHub token found, using unauthenticated requests (60/hour limit)")
              return token

          def parse_version(version_str: str) -> Optional[Tuple[int, int, int]]:
              """Extract a semantic version tuple from a string."""
              if not version_str:
                  return None

              match = VERSION_CANDIDATE_RE.search(version_str)
              if not match:
                  return None

              matched_text = match.group(0)
              if '.' not in matched_text and '_' not in matched_text:
                  return None

              major = int(match.group('major'))
              minor = int(match.group('minor'))
              patch = int(match.group('patch') or 0)
              return major, minor, patch


          def format_version_tuple(version: Tuple[int, int, int]) -> str:
              """Convert a version tuple to a canonical dotted string."""
              major, minor, patch = version
              return f"{major}.{minor}.{patch}"


          def find_release_version(
              metadata: Dict,
              preferred_asset: Optional[str] = None,
          ) -> Tuple[Optional[str], Optional[str]]:
              """Determine the most likely version string from release metadata."""

              candidate_sources: List[Tuple[str, str]] = []

              def add_candidate(value: Optional[str], source: str) -> None:
                  if value:
                      candidate_sources.append((value, source))

              add_candidate(metadata.get('tag_name'), 'tag')
              add_candidate(metadata.get('name'), 'release name')

              assets = metadata.get('assets') or []

              if preferred_asset:
                  for asset in assets:
                      if asset.get('name') == preferred_asset:
                          asset_name = asset.get('name')
                          if asset_name:
                              add_candidate(asset_name, f"asset '{asset_name}'")

                          asset_label = asset.get('label')
                          if asset_label:
                              add_candidate(asset_label, f"asset label '{asset_label}'")
                          break

              for asset in assets:
                  asset_name = asset.get('name')
                  if asset_name and asset_name != preferred_asset:
                      add_candidate(asset_name, f"asset '{asset_name}'")

                  asset_label = asset.get('label')
                  if asset_label:
                      add_candidate(asset_label, f"asset label '{asset_label}'")

              body = metadata.get('body')
              if body:
                  add_candidate(body[:1000], 'release notes')

              seen: set[Tuple[int, int, int]] = set()

              for text, source in candidate_sources:
                  parsed = parse_version(text)
                  if not parsed:
                      continue

                  if parsed in seen:
                      continue

                  seen.add(parsed)
                  return format_version_tuple(parsed), source

              return None, None

          def compare_versions(v1: str, v2: str) -> int:
              """
              Compare two version strings.
              Returns: 1 if v1 > v2, -1 if v1 < v2, 0 if equal
              """
              parsed_v1 = parse_version(v1)
              parsed_v2 = parse_version(v2)

              if not parsed_v1 or not parsed_v2:
                  return 0

              if parsed_v1 > parsed_v2:
                  return 1
              elif parsed_v1 < parsed_v2:
                  return -1
              return 0

          def get_latest_github_release(
              repo: str,
              token: str,
              preferred_asset: Optional[str] = None,
          ) -> Optional[Dict]:
              """
              Query GitHub API for latest release.
              Returns: {'version': 'v1.2.3', 'tag_name': 'v1.2.3', 'published_at': '...'}
              """
              url = f"https://api.github.com/repos/{repo}/releases/latest"
              headers = {}
              if token:
                  headers['Authorization'] = f'token {token}'

              try:
                  response = requests.get(url, headers=headers, timeout=10)

                  # Check rate limit
                  remaining = response.headers.get('X-RateLimit-Remaining', 'unknown')
                  print(f"  Rate limit remaining: {remaining}")

                  if response.status_code == 404:
                      print(f"  âš ï¸  No releases found for {repo}")
                      return None

                  response.raise_for_status()
                  data = response.json()
                  version, source = find_release_version(data, preferred_asset)

                  return {
                      'version': version or data.get('tag_name', ''),
                      'tag_name': data.get('tag_name'),
                      'published_at': data.get('published_at'),
                      'html_url': data.get('html_url'),
                      'version_source': source,
                  }
              except requests.exceptions.RequestException as e:
                  print(f"  âŒ Error fetching {repo}: {e}")
                  return None

          def main():
              # Load mods.json
              mods_file = Path('mods.json')
              if not mods_file.exists():
                  print("âŒ mods.json not found!")
                  sys.exit(1)

              with open(mods_file, 'r', encoding='utf-8') as f:
                  data = json.load(f)

              mods = data.get('mods', [])
              token = get_github_token()
              dry_run = os.environ.get('DRY_RUN', 'false').lower() == 'true'

              if dry_run:
                  print("ðŸ” DRY RUN MODE - No changes will be committed\n")

              print(f"ðŸ“¦ Checking {len(mods)} mods for updates...\n")

              updates = []
              errors = []

              for mod in mods:
                  mod_name = mod.get('name', 'Unknown')
                  current_version = mod.get('version', '0.0.0')
                  download_info = mod.get('download', {})

                  if download_info.get('type') != 'github_release':
                      continue

                  repo = download_info.get('repo')
                  if not repo:
                      continue

                  print(f"ðŸ” Checking {mod_name} (current: {current_version})")

                  # Query GitHub for latest release
                  preferred_asset = download_info.get('asset')
                  latest_release = get_latest_github_release(repo, token, preferred_asset)

                  if not latest_release:
                      errors.append(mod_name)
                      continue

                  latest_version = latest_release['version']
                  version_source = latest_release.get('version_source')
                  raw_tag = latest_release.get('tag_name')

                  if version_source:
                      print(f"  Latest on GitHub: {latest_version} (from {version_source})")
                      if raw_tag and raw_tag != latest_version:
                          print(f"    â†³ Release tag: {raw_tag}")
                  else:
                      print(f"  Latest on GitHub: {latest_version or 'unknown'}")

                  latest_version_tuple = parse_version(latest_version)
                  if not latest_version_tuple:
                      print("  âš ï¸  Unable to determine version number from release metadata")
                      errors.append(mod_name)
                      continue

                  # Compare versions
                  if compare_versions(latest_version, current_version) > 0:
                      print(f"  âœ… Update available: {current_version} â†’ {latest_version}")
                      updates.append({
                          'mod': mod,
                          'old_version': current_version,
                          'new_version': latest_version,
                          'release_url': latest_release['html_url']
                      })

                      # Update mod entry
                      mod['version'] = latest_version
                  else:
                      print(f"  âœ“ Up to date")

                  print()

              # Summary
              print("\n" + "="*60)
              print(f"ðŸ“Š Summary:")
              print(f"  Total mods checked: {len([m for m in mods if m.get('download', {}).get('type') == 'github_release'])}")
              print(f"  Updates found: {len(updates)}")
              print(f"  Errors: {len(errors)}")

              if updates:
                  print(f"\nðŸŽ‰ Updates to apply:")
                  for update in updates:
                      print(f"  - {update['mod']['name']}: {update['old_version']} â†’ {update['new_version']}")

              if errors:
                  print(f"\nâš ï¸  Mods with errors:")
                  for mod_name in errors:
                      print(f"  - {mod_name}")

              # Save changes
              if updates and not dry_run:
                  with open(mods_file, 'w', encoding='utf-8') as f:
                      json.dump(data, f, indent=2, ensure_ascii=False)
                      f.write('\n')  # Add trailing newline

                  print(f"\nâœ… Updated mods.json with {len(updates)} version changes")

                  # Set output for commit step
                  with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                      f.write(f"updates_found=true\n")
                      f.write(f"update_count={len(updates)}\n")
                      # Create commit message
                      if len(updates) == 1:
                          update = updates[0]
                          msg = f"Auto-sync: Updated {update['mod']['name']} to {update['new_version']}"
                      else:
                          msg = f"Auto-sync: Updated {len(updates)} mods to latest versions"
                      f.write(f"commit_message={msg}\n")
              else:
                  with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                      f.write(f"updates_found=false\n")

                  if not updates:
                      print("\nâœ“ All mods are up to date!")
                  elif dry_run:
                      print("\nðŸ” Dry run complete - no changes made")

          if __name__ == '__main__':
              main()
          EOF

      - name: Commit and push changes
        if: steps.sync-versions.outputs.updates_found == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add mods.json
          git commit -m "${{ steps.sync-versions.outputs.commit_message }}"
          git push

      - name: Create summary
        if: always()
        run: |
          echo "## ðŸ“¦ Version Sync Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.sync-versions.outputs.updates_found }}" == "true" ]; then
            echo "âœ… Updated ${{ steps.sync-versions.outputs.update_count }} mod(s)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Changes committed and pushed to main branch." >> $GITHUB_STEP_SUMMARY
          else
            echo "âœ“ All mods are up to date!" >> $GITHUB_STEP_SUMMARY
          fi
